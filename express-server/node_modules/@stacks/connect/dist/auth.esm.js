import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import _regeneratorRuntime from 'regenerator-runtime';
import { AppConfig, UserSession } from '@stacks/auth';
import { getStacksProvider } from './utils.esm.js';

var defaultAuthURL = "https://app.blockstack.org";
var version = "5.5.0";

if (typeof window !== "undefined") {
  window.__CONNECT_VERSION__ = version;
}

var isMobile = function isMobile() {
  var ua = navigator.userAgent;

  if (/android/i.test(ua)) {
    return true;
  }

  if (/iPad|iPhone|iPod/.test(ua)) {
    return true;
  }

  return /windows phone/i.test(ua);
};
var shouldUsePopup = function shouldUsePopup() {
  return !isMobile();
};
var getOrCreateUserSession = function getOrCreateUserSession(userSession) {
  if (!userSession) {
    var appConfig = new AppConfig(["store_write"], document.location.href);
    userSession = new UserSession({
      appConfig: appConfig
    });
  }

  return userSession;
};
var authenticate = function authenticate(authOptions) {
  var provider = getStacksProvider();

  if (!provider) {
    throw new Error("Unable to authenticate without Stacks Wallet extension");
  }

  var _authOptions$redirect = authOptions.redirectTo,
      redirectTo = _authOptions$redirect === void 0 ? "/" : _authOptions$redirect,
      manifestPath = authOptions.manifestPath,
      finished = authOptions.finished,
      onFinish = authOptions.onFinish,
      onCancel = authOptions.onCancel,
      _authOptions$sendToSi = authOptions.sendToSignIn,
      sendToSignIn = _authOptions$sendToSi === void 0 ? false : _authOptions$sendToSi,
      _userSession = authOptions.userSession,
      appDetails = authOptions.appDetails;
  var userSession = getOrCreateUserSession(_userSession);

  if (userSession.isUserSignedIn()) {
    userSession.signUserOut();
  }

  var transitKey = userSession.generateAndStoreTransitKey();
  var authRequest = userSession.makeAuthRequest(transitKey, "" + document.location.origin + redirectTo, "" + document.location.origin + manifestPath, userSession.appConfig.scopes, void 0, void 0, {
    sendToSignIn: sendToSignIn,
    appDetails: appDetails,
    connectVersion: version
  });
  void provider.authenticationRequest(authRequest).then( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(authResponse) {
      var success;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return userSession.handlePendingSignIn(authResponse);

            case 2:
              success = onFinish || finished;
              success == null ? void 0 : success({
                authResponse: authResponse,
                userSession: userSession
              });

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }())["catch"](function (error) {
    console.error("[Connect] Error during auth request", error);
    onCancel == null ? void 0 : onCancel();
  });
};
var getUserData = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(userSession) {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            userSession = getOrCreateUserSession(userSession);

            if (!userSession.isUserSignedIn()) {
              _context2.next = 3;
              break;
            }

            return _context2.abrupt("return", userSession.loadUserData());

          case 3:
            if (!userSession.isSignInPending()) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return", userSession.handlePendingSignIn());

          case 5:
            return _context2.abrupt("return", null);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getUserData(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

export { authenticate, defaultAuthURL, getOrCreateUserSession, getUserData, isMobile, shouldUsePopup };
//# sourceMappingURL=auth.esm.js.map
